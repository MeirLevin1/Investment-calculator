import matplotlib.pyplot as plt
import matplotlib.ticker as mticker
import numpy as np
import ipywidgets as widgets
from ipywidgets import VBox, HBox, Layout, interactive_output
from IPython.display import display, clear_output
import math # Needed for floor division

# --- Constants ---
# --- Changed from CAR_PRICE to HOUSE_PRICE and updated value ---
HOUSE_PRICE = 2000000 # Approximate price of a house in ILS

# --- Core Calculation Logic (adapted to be a simple function) ---
def calculate_growth(initial_amount, start_age, monthly_investment, monthly_withdrawal, annual_interest_rate_percent, end_age=80):
    """Calculates investment growth based on input parameters."""
    monthly_interest_rate = annual_interest_rate_percent / 100 / 12
    ages = []
    amounts = []
    stop_calculation = False

    current_balance = initial_amount
    if current_balance >= 0:
        ages.append(start_age)
        amounts.append(current_balance)
    else:
        # Cannot start with negative balance in this model
        return [], [] # Return empty lists

    for age in range(start_age, end_age):
        if stop_calculation:
            break # Stop outer loop if balance depleted

        for month in range(12):
            if current_balance <= 0:
                current_balance = 0
                stop_calculation = True
                break # Stop inner loop

            interest_earned = current_balance * monthly_interest_rate
            current_balance += interest_earned
            current_balance += monthly_investment
            current_balance -= monthly_withdrawal

            if current_balance < 0:
                current_balance = 0
                # stop_calculation = True # Optional: stop immediately if zeroed by withdrawal
                # break

        # Store end-of-year balance
        if not stop_calculation:
            if not ages or ages[-1] != age + 1:
                ages.append(age + 1)
                amounts.append(max(0, current_balance))
            else: # Should not happen with current logic, but safe guard
                 amounts[-1] = max(0, current_balance)
        else:
            # Add the final zero balance point if needed
            if ages and ages[-1] != age + 1:
                ages.append(age + 1)
                amounts.append(0)
            break # Exit year loop

    return ages, amounts

# --- Plotting Function ---
def plot_growth(ages, amounts, start_age, end_age, initial_amount, monthly_investment, monthly_withdrawal, annual_interest_rate_percent):
    """Generates and displays the matplotlib plot with text annotations for houses."""
    plt.figure(figsize=(12, 7)) # Slightly smaller figure for widget layout

    if not ages or not amounts:
        plt.title('No data to display. Check inputs.')
        plt.text(0.5, 0.5, 'No data available.', horizontalalignment='center', verticalalignment='center', transform=plt.gca().transAxes)
        plt.show()
        return # Exit if no data

    # --- Actual Plotting ---
    plt.plot(ages, amounts, marker='.', linestyle='-', color='b', label='Investment Growth')

    # --- Annotations with Text ("X houses") ---
    milestone_ages = [age for age in ages if age >= start_age and age % 5 == 0 and age <= end_age]
    milestone_ages_with_amount = []
    for age_ms in milestone_ages:
        try:
            index_ms = ages.index(age_ms)
            # Only consider milestones where at least one house can be bought
            # --- Using HOUSE_PRICE ---
            if amounts[index_ms] >= HOUSE_PRICE:
                 milestone_ages_with_amount.append(age_ms)
        except (ValueError, IndexError): pass

    for milestone_age in milestone_ages_with_amount:
        try:
            index = ages.index(milestone_age)
            amount_at_milestone = amounts[index]
            # --- Using HOUSE_PRICE ---
            num_houses = math.floor(amount_at_milestone / HOUSE_PRICE) # Calculate number of houses

            if num_houses > 0:
                # --- Changed annotation to text "houses" ---
                annotation_str = f"{num_houses} houses"

                vertical_offset = amount_at_milestone * 0.03 # Slightly larger offset
                plt.text(milestone_age, amount_at_milestone + vertical_offset, annotation_str,
                         fontsize=8, # Consistent font size for text
                         ha='center',
                         va='bottom',
                         bbox=dict(boxstyle='round,pad=0.2', fc='lightgreen', alpha=0.7, ec='none')) # Changed background color
            # else: don't annotate if less than one house can be bought
        except (ValueError, IndexError): pass

    # --- Formatting ---
    plt.title(f'Investment Growth (Compound Interest) from Age {start_age} to {end_age}', fontsize=14)
    plt.xlabel('Age', fontsize=10)
    plt.ylabel('Accumulated Amount (₪)', fontsize=10)
    plt.grid(True, which='both', linestyle='--', linewidth=0.5)

    ax = plt.gca()
    ax.yaxis.set_major_formatter(mticker.FuncFormatter(lambda x, p: format(int(x), ',')))

    min_y = min(amounts) if amounts else 0
    max_y = max(amounts) if amounts else 1
    # --- Adjust max Y based on HOUSE_PRICE ---
    if max_y < 1: max_y = 5 * HOUSE_PRICE # Adjust max Y if needed based on house price
    ax.set_ylim(bottom=min(0, min_y * 1.1), top=max_y * 1.15) # Increased top padding

    tick_start = start_age if start_age % 5 == 0 else start_age - (start_age % 5)
    all_ticks = sorted(list(set(range(tick_start, end_age + 1, 5))))
    plt.xticks(all_ticks, rotation=45, ha="right", fontsize=9)
    plt.xlim(start_age, end_age)

    # --- Final Amount Text (Still shows currency) ---
    final_amount = amounts[-1] if amounts else 0
    final_age_actual = ages[-1] if ages else end_age
    final_amount_text = f"Final Amount:\n₪{final_amount:,.2f}" # Keep final amount in currency
    text_x_pos = final_age_actual * 0.98 if final_age_actual > start_age else start_age + (end_age - start_age) * 0.02
    text_y_pos = final_amount * 0.7 if final_amount > 0 else max_y * 0.1

    # Check if the last age is a milestone to avoid overlap with house annotations
    is_last_milestone_annotated = False
    if final_age_actual in milestone_ages_with_amount:
         is_last_milestone_annotated = True

    if final_amount > 0.01 and not is_last_milestone_annotated:
        plt.text(text_x_pos, text_y_pos, final_amount_text,
                 fontsize=9, ha='right',
                 bbox=dict(boxstyle='round,pad=0.5', fc='yellow', alpha=0.7))
    elif final_amount <= 0.01 and final_age_actual > start_age:
         plt.text(final_age_actual, max_y * 0.1, f"Balance depleted at Age {final_age_actual}",
                  fontsize=9, ha='center', va='center', color='red',
                  bbox=dict(boxstyle='round,pad=0.5', fc='white', alpha=0.7))

    plt.tight_layout()
    plt.show()

    # --- Print Summary ---
    print(f"\n--- Summary ---")
    print(f"Initial: ₪{initial_amount:,.2f} | Start Age: {start_age}")
    print(f"Monthly Deposit: ₪{monthly_investment:,.2f} | Monthly Withdrawal: ₪{monthly_withdrawal:,.2f}")
    # --- Updated summary with HOUSE_PRICE ---
    print(f"Annual Rate: {annual_interest_rate_percent}% | Assumed House Price: ₪{HOUSE_PRICE:,.0f}")
    if amounts:
        print(f"Final Amount at Age {final_age_actual}: ₪{final_amount:,.2f}")
        # Also show final house count in summary
        # --- Using HOUSE_PRICE ---
        final_houses = math.floor(final_amount / HOUSE_PRICE)
        if final_houses > 0:
             # --- Changed summary to text "houses" ---
            print(f"Equivalent to approx. {final_houses} houses")
    else:
        print("No final amount data to display.")


# --- Create Widgets ---
style = {'description_width': 'initial'} # Allow longer descriptions
layout = Layout(width='auto', margin='5px') # Adjust width and margin

initial_amount_w = widgets.FloatText(value=100000, description="Initial Amount (₪):", style=style, layout=layout, step=1000)
start_age_w = widgets.IntText(value=30, description="Start Age:", style=style, layout=layout, step=1)
monthly_investment_w = widgets.FloatText(value=1000, description="Monthly Deposit (₪):", style=style, layout=layout, step=100)
monthly_withdrawal_w = widgets.FloatText(value=0, description="Monthly Withdrawal (₪):", style=style, layout=layout, step=100)
annual_rate_w = widgets.FloatText(value=7.0, description="Annual Rate (%):", style=style, layout=layout, step=0.1)
# end_age_w = widgets.IntText(value=80, description="End Age:", style=style, layout=layout) # Optional: make end_age interactive too

# --- Output Widget for the plot ---
plot_output = widgets.Output()

# --- Define the function to be called on widget changes ---
def update_plot(initial, age, invest, withdraw, rate):
    """Clears output, recalculates, and replots."""
    with plot_output:
        clear_output(wait=True) # Clear previous plot before drawing new one
        # Use fixed end_age=80 for now, or pass end_age_w.value if widget is added
        ages_data, amounts_data = calculate_growth(initial, age, invest, withdraw, rate, end_age=80)
        plot_growth(ages_data, amounts_data, age, 80, initial, invest, withdraw, rate) # Pass all params for summary

# --- Link Widgets to the Update Function ---
# Use interactive_output to connect the widgets to the update function.
# The update function will run whenever any of the linked widget values change.
ui = VBox([
    HBox([initial_amount_w, start_age_w]),
    HBox([monthly_investment_w, monthly_withdrawal_w]),
    HBox([annual_rate_w]),
    plot_output # The area where the plot will appear
])

# Define the interactive linkage
interactive_plot = interactive_output(update_plot, {
    'initial': initial_amount_w,
    'age': start_age_w,
    'invest': monthly_investment_w,
    'withdraw': monthly_withdrawal_w,
    'rate': annual_rate_w
    # 'end': end_age_w # Add if end_age widget is used
})

# --- Display the UI ---
print("Adjust the values below to see the graph update:")
display(ui)
# Trigger the initial plot calculation
update_plot(initial_amount_w.value, start_age_w.value, monthly_investment_w.value, monthly_withdrawal_w.value, annual_rate_w.value)
